#!/usr/bin/perl

# map

use strict;
use warnings;

use Cwd;
use File::Basename  qw[basename dirname];
use File::Find;
  no warnings 'File::Find';
use File::Glob      qw[:glob];
use File::Path      qw[make_path];
use File::Spec      qw[catfile];
  sub fsc { File::Spec->catfile(@_) }

local $\ = "\n";
local $|; $|++;

sub make_directory;
sub make_link;
sub readlink_f;

my $action = $ARGV[0] // 'add';

chdir dirname "$0"
  or die "Error changing directory to dirname($0): $!";

my @globs;
while (<DATA>) {
  chomp;
  push @globs, $_;
}
close DATA;

for my $glob ( @globs ) {

  for my $file ( my @files = bsd_glob $glob ) {
      
    my ($relative_file) = ($file =~ m[^\s*$ENV{HOME}\/(.*)$]);
    my $realfile = readlink $file // $file;

    next unless length $relative_file 
                and -e $realfile;

    printf "Committing '%s' as '%s'\n", $file, $relative_file
      if not -e $relative_file;

    if ( -d $realfile ) {
      make_directory ( $relative_file ) 
        if not -d $relative_file;

      find { 
          wanted => sub {
            my ($relative_name) = 
              ($File::Find::name =~ m[^\s*$ENV{HOME}\/(.*)$]);

            if ( -l (my $realfile = $File::Find::name) or -f _ ) {
              $realfile = readlink_f $File::Find::name if -l _;
              make_link( $realfile, $relative_name );
            }
            elsif ( -d _ ) {
              make_directory( $relative_name );
            }
            else {
              warn "Not processing '$File::Find::name', possible special file.\n";
            }
          }, 
          no_chdir => 1
        }, 
        $realfile;
    }

    elsif ( $relative_file =~ m[\/] ) { 
      make_directory  ( dirname($relative_file) ) 
        if not -d dirname($relative_file);

      make_link ( $realfile, $relative_file );
    }

    else {
      make_link ( $realfile, $relative_file );
    }
  }

}

sub make_directory {
  my $directory = shift;

  warn "Error creating directory '$directory': $!\n"
    if (  not -d $directory           and
          print "mkdir -p $directory" and
          not make_path($directory)   and
          return 1
        ); 
}

sub make_link {
  my ($target, $link) = (@_);

  warn "Error creating link '$link' to '$target': $!\n"
    if (  not -f $link                 and 
          print "ln '$target' '$link'" and
          not link $target, $link      and
          return 1
        );

}

# Courtesy: R.Schwartz
# "Expanding symbolic links (aug 99)"
#  http://www.stonehenge.com/merlyn/UnixReview/col27.html
sub readlink_f {
  my $file = shift;

  my @right = split /\//, $file;

  my @left = do {
    @right && ($right[0] eq "") ?
    shift @right :            # quick way
    split /\//, getcwd;
  };    # first element always null

  while (@right) {
    my $item = shift @right;
    next if $item eq "." or $item eq "";

    if ($item eq "..") {
      pop @left if @left > 1;
      next;
    }

    my $link = readlink fsc(@left, $item);

    if (defined $link) {
      my @parts = split /\//, $link;
      if (@parts && ($parts[0] eq "")) { # absolute
        @left = shift @parts;   # quick way
      }
      unshift @right, @parts;
      next;
    } 
    else {
      push @left, $item;
      next;
    }
  }

  return fsc(@left);
}

# TODO
#   * Add a reverse action of 'add' - consider better verbage
#   * Targets need to take on name as listed in __DATA__ not the real filename
#   * __DATA__ should really exist in a synclist file


__DATA__
~/~/.config/wallpapers/wallpaper.list
~/.config/zim/accelmap
~/.config/zim/default.conf
~/.config/zim/mklinks
~/.config/zim/state.conf
~/.dircolors
~/.fehrc
~/.fluxbox/apps
~/.fluxbox/init
~/.fluxbox/keys
~/.fluxbox/menu
~/.fluxbox/overlay
~/.fluxbox/startup
~/.fluxbox/windowmenu
~/.gitignore
~/.gmrunrc
~/.gtkrc-2.0
~/.ideskrc
~/.idesktop
~/.inputrc
~/.local/share/applications
~/.profile
~/.screenrc
~/.tmux.conf
~/.vimperator/plugin/
~/.vimperatorrc
~/.Xdefaults
~/.xinitrc
~/.Xmodmap
~/.xsession
~/.bin/qterm
